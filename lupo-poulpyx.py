import numpy as np
import matplotlib.pyplot as plt
import os
from pathlib import Path
import tkinter as tk
import tkinter.filedialog as fd
from tkinter import Tk,DoubleVar,StringVar,Radiobutton

# Select the Lupo spectrum file (chi file for Fit2D, rgr file for PySAXS), import q and i
root = Tk()
file_extensions = ['*.chi','*.rgr']
ftypes = [
    ('chi and rgr files (*.chi, *.rgr)', file_extensions),
    ('All files', '*'),
]
file = fd.askopenfilename(parent=root, title='Select a lupo (PE) spectrum',filetypes=ftypes)
root.destroy()

if file.endswith(".chi") or file.endswith(".rgr"):
    folderpath = os.path.dirname(os.path.abspath(file))
    filepath = os.path.abspath(file)
    filename = Path(str(file)).stem
    if file.endswith(".chi"):
        q,i = np.loadtxt(file, unpack=True, skiprows=4)
    elif file.endswith(".rgr"):
        q,i = np.loadtxt(file, unpack=True, skiprows=23, usecols=(0,1))

# Import the file with the transmission and time for Lupo and matching vacuum, generated by poulpyx previously
root2 = Tk()
file_extensions2 = ['*.txt']
ftypes2 = [
    ('text files (*.txt)', file_extensions2),
    ('All files', '*'),
]
file2 = fd.askopenfilename(parent=root2, title='Select the lupo.txt file',filetypes=ftypes2)
root2.destroy()

file22 = open(file2, 'r')
searchlines = file22.readlines()
file22.close()
for line in searchlines:
    a = line.split()
    if a[0] == ("Lupo/PE"):
        tr_lupo = a[1]
        time_lupo = a[2]
    if a[0] == ("Vacuum"):
        tr_vacuum = a[1]

# Creation of the window with the measurement parameters
def close_window():
    gui.destroy()

gui = Tk()

tk.Label(gui, text="Transmission PE").grid(row=0)
tk.Label(gui, text="Transmission vide").grid(row=1)
tk.Label(gui, text="t(s)").grid(row=2)
tk.Label(gui, text="Phi (flux pendant la manip)").grid(row=3)
tk.Label(gui, text="e (cm)").grid(row=4)
tk.Label(gui, text="BF electronic").grid(row=5)
tk.Label(gui, text="Phi normalization PE ").grid(row=6)

a1 = DoubleVar()
a2 = DoubleVar()
a3 = DoubleVar()
a4 = DoubleVar()
a5 = DoubleVar()
a6 = DoubleVar()
a7 = DoubleVar()

a1.set(tr_lupo)    #everything auto-filled
a2.set(tr_vacuum)
a3.set(time_lupo)
a4.set(1.0)
a5.set(0.238)
a6.set(8.0)
a7.set(1.0)

e1 = tk.Entry(gui, textvariable=a1)
e2 = tk.Entry(gui, textvariable=a2)
e3 = tk.Entry(gui, textvariable=a3)
e4 = tk.Entry(gui, textvariable=a4)
e5 = tk.Entry(gui, textvariable=a5)
e6 = tk.Entry(gui, textvariable=a6)
e7 = tk.Entry(gui, textvariable=a7)

e1.grid(row=0, column=1)
e2.grid(row=1, column=1)
e3.grid(row=2, column=1)
e4.grid(row=3, column=1)
e5.grid(row=4, column=1)
e6.grid(row=5, column=1)
e7.grid(row=6, column=1)

v = StringVar()
v.set("nm-1")
r1 = Radiobutton(gui, text="A-1", variable=v, value="A-1").grid(row=7, column=0)
r2 = Radiobutton(gui, text="nm-1", variable=v, value="nm-1").grid(row=7, column=1)

button = tk.Button(text = "OK", command = close_window, width=4, height=2).grid(row=8, pady=10)

gui.mainloop()

# Getting the values, for calculation
Tr_pe = a1.get()
Tr_vide = a2.get()
temps = a3.get()
Phi_manip = a4.get()
epaisseur = a5.get()
BF_elec = a6.get()
Phi_PE = a7.get()

Tr_div = Tr_pe/Tr_vide
Phi_div = Phi_PE/Phi_manip

# Finding the two values around q=0.37nm-1, generating an artificial point at 0.37 nm-1 by linear interpolation
unit_selected = v.get()
if unit_selected=="A-1":
    q_peak=0.037
    xmax = 0.1
elif unit_selected=="nm-1":
    q_peak=0.37
    xmax = 1.0

for h in np.arange(0,len(q),1):
    if q[h] < q_peak:
        x1 = q[h]
        x2 = q[h+1]
        y1 = i[h]
        y2 = i[h+1]
pente = (y1-y2)/(x1-x2)
intersect = y1 - pente*x1
i_artif = pente*q_peak + intersect

# Then we loop on k to get the closest I to 4.9 cm-1
setdif = 10000
for k in np.arange(0.001, 20.001, 0.001):
    I_norm_test = ((i_artif-BF_elec)/(epaisseur*Tr_div*temps))*Phi_div*k
    if abs(I_norm_test-4.9)<setdif:
        kset = k
        setdif = abs(I_norm_test-4.9)

I_norm_test = ((i_artif-BF_elec)/(epaisseur*Tr_div*temps))*Phi_div*kset
I_norm = ((i-BF_elec)/(epaisseur*Tr_div*temps))*Phi_div*kset

plt.xlim(0,xmax)
plt.plot(q, I_norm)
plt.plot(q_peak, I_norm_test,marker='+', ms=8, color='k')
plt.text(0.6*xmax,6, "k ="+str(kset), color='r', size=16, weight='bold')
plt.show()

print("Normalisation factor k =", kset)
